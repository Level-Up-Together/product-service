name: Build and Deploy (Prod)

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      skip_deploy:
        description: 'Build only (skip deploy to EC2)'
        required: false
        default: 'false'
        type: boolean

permissions:
  id-token: write   # GitHub OIDC → AWS
  contents: read

env:
  S3_BUCKET: lut-deploy-prod
  APP_NAME: product-service

jobs:
  build:
    name: Build & Upload
    runs-on: ubuntu-latest
    outputs:
      jar_filename: ${{ steps.upload.outputs.jar_filename }}

    steps:
      # 1. SSH 호스트 키 추가
      - name: Add SSH known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H github.com >> ~/.ssh/known_hosts

      # 2. 리포지토리 체크아웃 (서브모듈 포함)
      - name: Checkout repository with submodules
        uses: actions/checkout@v4
        with:
          submodules: recursive
          ssh-key: ${{ secrets.PRIVATE_KEY_FOR_SUBMODULE }}
          fetch-depth: 0

      # 3. 서브모듈 최신화
      - name: Update submodules to the latest
        run: |
          git submodule update --init --recursive
          git submodule foreach git pull origin $(git rev-parse --abbrev-ref HEAD)

      # 4. Keystore 파일 복원
      - name: Restore keystore from secrets
        run: |
          echo "$KEYSTORE_BASE64" | base64 -d > app/src/main/resources/keystore-prod.p12
          echo "Keystore (prod) restored successfully"
        env:
          KEYSTORE_BASE64: ${{ secrets.PROD_KEYSTORE_BASE64 }}

      # 5. JDK 설정
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: 'gradle'

      # 6. Gradle 캐시 설정
      - name: Cache Gradle packages
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-

      # 7. Gradle 빌드
      - name: Build with Gradle
        run: |
          RELEASE_VERSION=$(grep lutPlatformReleaseVersion gradle.properties | cut -d= -f2)
          ./gradlew clean build --no-daemon -PlutPlatformVersion="$RELEASE_VERSION"
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PACKAGES_TOKEN }}

      # 8. AWS OIDC 인증
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ap-northeast-2

      # 9. JAR → S3 업로드
      - name: Upload JAR to S3
        id: upload
        run: |
          JAR_FILE=$(ls app/build/libs/*-exec.jar | head -1)
          JAR_FILENAME=$(basename "$JAR_FILE")
          COMMIT_SHA=${GITHUB_SHA::8}
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)

          # JAR 파일명을 deploy job에 전달
          echo "jar_filename=$JAR_FILENAME" >> "$GITHUB_OUTPUT"

          # 커밋별 아카이브
          aws s3 cp "$JAR_FILE" "s3://$S3_BUCKET/$APP_NAME/${TIMESTAMP}-${COMMIT_SHA}.jar"

          # latest.jar (배포용)
          aws s3 cp "$JAR_FILE" "s3://$S3_BUCKET/$APP_NAME/latest.jar"

          echo "Uploaded: $JAR_FILENAME -> s3://$S3_BUCKET/$APP_NAME/latest.jar"

  deploy:
    name: Rolling Deploy
    needs: build
    if: ${{ github.event.inputs.skip_deploy != 'true' }}
    runs-on: ubuntu-latest

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ap-northeast-2

      # ── EC2 #1: Deregister → Deploy → Register ──────
      - name: "[EC2 #1] Deregister from ALB"
        env:
          TG_ARN: ${{ secrets.PROD_PRODUCT_TG_ARN }}
          EC2_ID: ${{ secrets.PROD_EC2_1_ID }}
        run: |
          aws elbv2 deregister-targets \
            --target-group-arn "$TG_ARN" \
            --targets Id=$EC2_ID,Port=8443
          echo "Deregistered EC2 #1 from product target group"

      - name: "[EC2 #1] Wait for drain"
        env:
          TG_ARN: ${{ secrets.PROD_PRODUCT_TG_ARN }}
          EC2_ID: ${{ secrets.PROD_EC2_1_ID }}
        run: |
          echo "Waiting for connections to drain..."
          aws elbv2 wait target-deregistered \
            --target-group-arn "$TG_ARN" \
            --targets Id=$EC2_ID,Port=8443 || true
          echo "EC2 #1 drained"

      - name: "[EC2 #1] Deploy via SSM"
        env:
          EC2_ID: ${{ secrets.PROD_EC2_1_ID }}
          JAR_FILENAME: ${{ needs.build.outputs.jar_filename }}
        run: |
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$EC2_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters "commands=[\"sudo /opt/apps/deploy.sh $APP_NAME $S3_BUCKET $APP_NAME/latest.jar $JAR_FILENAME\"]" \
            --timeout-seconds 300 \
            --query "Command.CommandId" --output text)
          echo "Command ID: $COMMAND_ID"

          aws ssm wait command-executed \
            --command-id "$COMMAND_ID" --instance-id "$EC2_ID" 2>/dev/null || true

          STATUS=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" --instance-id "$EC2_ID" \
            --query "Status" --output text)
          OUTPUT=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" --instance-id "$EC2_ID" \
            --query "StandardOutputContent" --output text)
          echo "$OUTPUT"

          if [ "$STATUS" != "Success" ]; then
            ERROR=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" --instance-id "$EC2_ID" \
              --query "StandardErrorContent" --output text)
            echo "$ERROR"
            exit 1
          fi

      - name: "[EC2 #1] Register to ALB"
        env:
          TG_ARN: ${{ secrets.PROD_PRODUCT_TG_ARN }}
          EC2_ID: ${{ secrets.PROD_EC2_1_ID }}
        run: |
          aws elbv2 register-targets \
            --target-group-arn "$TG_ARN" \
            --targets Id=$EC2_ID,Port=8443
          echo "Registered EC2 #1 back to product target group"

      - name: "[EC2 #1] Wait for healthy"
        env:
          TG_ARN: ${{ secrets.PROD_PRODUCT_TG_ARN }}
          EC2_ID: ${{ secrets.PROD_EC2_1_ID }}
        run: |
          echo "Waiting for EC2 #1 to pass health check..."
          aws elbv2 wait target-in-service \
            --target-group-arn "$TG_ARN" \
            --targets Id=$EC2_ID,Port=8443
          echo "EC2 #1 is healthy"

      # ── EC2 #2: Deregister → Deploy → Register ──────
      - name: "[EC2 #2] Deregister from ALB"
        env:
          TG_ARN: ${{ secrets.PROD_PRODUCT_TG_ARN }}
          EC2_ID: ${{ secrets.PROD_EC2_2_ID }}
        run: |
          aws elbv2 deregister-targets \
            --target-group-arn "$TG_ARN" \
            --targets Id=$EC2_ID,Port=8443
          echo "Deregistered EC2 #2 from product target group"

      - name: "[EC2 #2] Wait for drain"
        env:
          TG_ARN: ${{ secrets.PROD_PRODUCT_TG_ARN }}
          EC2_ID: ${{ secrets.PROD_EC2_2_ID }}
        run: |
          echo "Waiting for connections to drain..."
          aws elbv2 wait target-deregistered \
            --target-group-arn "$TG_ARN" \
            --targets Id=$EC2_ID,Port=8443 || true
          echo "EC2 #2 drained"

      - name: "[EC2 #2] Deploy via SSM"
        env:
          EC2_ID: ${{ secrets.PROD_EC2_2_ID }}
          JAR_FILENAME: ${{ needs.build.outputs.jar_filename }}
        run: |
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$EC2_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters "commands=[\"sudo /opt/apps/deploy.sh $APP_NAME $S3_BUCKET $APP_NAME/latest.jar $JAR_FILENAME\"]" \
            --timeout-seconds 300 \
            --query "Command.CommandId" --output text)
          echo "Command ID: $COMMAND_ID"

          aws ssm wait command-executed \
            --command-id "$COMMAND_ID" --instance-id "$EC2_ID" 2>/dev/null || true

          STATUS=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" --instance-id "$EC2_ID" \
            --query "Status" --output text)
          OUTPUT=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" --instance-id "$EC2_ID" \
            --query "StandardOutputContent" --output text)
          echo "$OUTPUT"

          if [ "$STATUS" != "Success" ]; then
            ERROR=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" --instance-id "$EC2_ID" \
              --query "StandardErrorContent" --output text)
            echo "$ERROR"
            exit 1
          fi

      - name: "[EC2 #2] Register to ALB"
        env:
          TG_ARN: ${{ secrets.PROD_PRODUCT_TG_ARN }}
          EC2_ID: ${{ secrets.PROD_EC2_2_ID }}
        run: |
          aws elbv2 register-targets \
            --target-group-arn "$TG_ARN" \
            --targets Id=$EC2_ID,Port=8443
          echo "Registered EC2 #2 back to product target group"

      - name: "[EC2 #2] Wait for healthy"
        env:
          TG_ARN: ${{ secrets.PROD_PRODUCT_TG_ARN }}
          EC2_ID: ${{ secrets.PROD_EC2_2_ID }}
        run: |
          echo "Waiting for EC2 #2 to pass health check..."
          aws elbv2 wait target-in-service \
            --target-group-arn "$TG_ARN" \
            --targets Id=$EC2_ID,Port=8443
          echo "EC2 #2 is healthy"

  notify:
    name: Slack Notification
    needs: [build, deploy]
    runs-on: ubuntu-latest
    if: always() && needs.deploy.result != 'skipped'

    steps:
      - name: action-slack
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ needs.deploy.result }}
          author_name: Level Up Together Backend - prod
          fields: repo,commit,message,author
          mention: here
          if_mention: failure,cancelled
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.PROD_SLACK_WEBHOOK_URL }}
