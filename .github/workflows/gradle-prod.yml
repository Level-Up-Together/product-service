name: Build and Deploy (Prod)

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      skip_deploy:
        description: 'Build only (skip deploy to EC2)'
        required: false
        default: 'false'
        type: boolean

permissions:
  id-token: write   # GitHub OIDC → AWS
  contents: read

env:
  S3_BUCKET: lut-deploy-prod
  APP_NAME: product-be

jobs:
  build:
    name: Build & Upload
    runs-on: ubuntu-latest

    steps:
      # 1. SSH 호스트 키 추가
      - name: Add SSH known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H github.com >> ~/.ssh/known_hosts

      # 2. 리포지토리 체크아웃 (서브모듈 포함)
      - name: Checkout repository with submodules
        uses: actions/checkout@v4
        with:
          submodules: recursive
          ssh-key: ${{ secrets.PRIVATE_KEY_FOR_SUBMODULE }}
          fetch-depth: 0

      # 3. 서브모듈 최신화
      - name: Update submodules to the latest
        run: |
          git submodule update --init --recursive
          git submodule foreach git pull origin $(git rev-parse --abbrev-ref HEAD)

      # 4. Keystore 파일 복원
      - name: Restore keystore from secrets
        run: |
          echo "$KEYSTORE_BASE64" | base64 -d > app/src/main/resources/keystore-prod.p12
          echo "Keystore (prod) restored successfully"
        env:
          KEYSTORE_BASE64: ${{ secrets.PROD_KEYSTORE_BASE64 }}

      # 5. JDK 설정
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: 'gradle'

      # 6. Gradle 캐시 설정
      - name: Cache Gradle packages
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-

      # 7. Gradle 빌드
      - name: Build with Gradle
        run: ./gradlew clean build --no-daemon
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PACKAGES_TOKEN }}

      # 8. AWS OIDC 인증
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ap-northeast-2

      # 9. JAR → S3 업로드
      - name: Upload JAR to S3
        run: |
          JAR_FILE=$(ls app/build/libs/*-exec.jar | head -1)
          COMMIT_SHA=${GITHUB_SHA::8}
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)

          # 커밋별 아카이브
          aws s3 cp "$JAR_FILE" "s3://$S3_BUCKET/$APP_NAME/${TIMESTAMP}-${COMMIT_SHA}.jar"

          # latest.jar (배포용)
          aws s3 cp "$JAR_FILE" "s3://$S3_BUCKET/$APP_NAME/latest.jar"

          echo "Uploaded: $JAR_FILE -> s3://$S3_BUCKET/$APP_NAME/latest.jar"

  deploy:
    name: Deploy to EC2
    needs: build
    if: ${{ github.event.inputs.skip_deploy != 'true' }}
    runs-on: ubuntu-latest

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ap-northeast-2

      # EC2 #1 배포 (순차: 롤링 배포)
      - name: Deploy to EC2 #1 via SSM
        run: |
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$EC2_1_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters "commands=[\"sudo /opt/apps/deploy.sh $APP_NAME $S3_BUCKET $APP_NAME/latest.jar\"]" \
            --timeout-seconds 120 \
            --query "Command.CommandId" \
            --output text)

          echo "SSM Command ID: $COMMAND_ID"

          for i in $(seq 1 40); do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$EC2_1_ID" \
              --query "Status" \
              --output text 2>/dev/null || echo "InProgress")

            echo "Attempt $i: Status=$STATUS"

            if [ "$STATUS" = "Success" ]; then
              echo "EC2 #1 deploy successful!"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$EC2_1_ID" \
                --query "StandardOutputContent" \
                --output text
              break
            elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then
              echo "EC2 #1 deploy failed with status: $STATUS"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$EC2_1_ID" \
                --query "StandardErrorContent" \
                --output text
              exit 1
            fi

            sleep 5
          done
        env:
          EC2_1_ID: ${{ secrets.PROD_EC2_1_ID }}

      # EC2 #2 배포
      - name: Deploy to EC2 #2 via SSM
        run: |
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$EC2_2_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters "commands=[\"sudo /opt/apps/deploy.sh $APP_NAME $S3_BUCKET $APP_NAME/latest.jar\"]" \
            --timeout-seconds 120 \
            --query "Command.CommandId" \
            --output text)

          echo "SSM Command ID: $COMMAND_ID"

          for i in $(seq 1 40); do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$EC2_2_ID" \
              --query "Status" \
              --output text 2>/dev/null || echo "InProgress")

            echo "Attempt $i: Status=$STATUS"

            if [ "$STATUS" = "Success" ]; then
              echo "EC2 #2 deploy successful!"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$EC2_2_ID" \
                --query "StandardOutputContent" \
                --output text
              break
            elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then
              echo "EC2 #2 deploy failed with status: $STATUS"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$EC2_2_ID" \
                --query "StandardErrorContent" \
                --output text
              exit 1
            fi

            sleep 5
          done
        env:
          EC2_2_ID: ${{ secrets.PROD_EC2_2_ID }}

  notify:
    name: Slack Notification
    needs: [build, deploy]
    runs-on: ubuntu-latest
    if: always() && needs.deploy.result != 'skipped'

    steps:
      - name: action-slack
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ needs.deploy.result }}
          author_name: Level Up Together Backend - prod
          fields: repo,commit,message,author
          mention: here
          if_mention: failure,cancelled
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.DEV_SLACK_WEBHOOK_URL }}
